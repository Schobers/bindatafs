package bindatafs

import (
	"os"
	"syscall"
	"time"

	"github.com/spf13/afero"
)

// AssetFn describes the Asset function as generated by go-bindata
type AssetFn func(name string) []byte

// InfoFn describes the AssetInfo function as generated by go-bindata
type InfoFn func(name string) (os.FileInfo, error)

// NamesFn describes the AssetNames function as generated by go-bindata
type NamesFn func() []string

// Fs describes the go-bindata asset functions
type Fs struct {
	tree  tree
	Asset AssetFn
	Info  InfoFn
	Names NamesFn
}

// NewFs creates a new Fs
func NewFs(asset AssetFn, info InfoFn, names NamesFn) *Fs {
	return &Fs{Asset: asset, Info: info, Names: names}
}

// _ makes sure fs implements the afero.Fs interface
var _ afero.Fs = &Fs{}

// Create creates a file in the filesystem, returning the file and an error, if any happens.
func (fs *Fs) Create(name string) (afero.File, error) { return nil, syscall.EPERM }

// Mkdir creates a directory in the filesystem, return an error if any happens.
func (fs *Fs) Mkdir(name string, perm os.FileMode) error { return syscall.EPERM }

// MkdirAll creates a directory path and all parents that does not exist yet.
func (fs *Fs) MkdirAll(path string, perm os.FileMode) error { return syscall.EPERM }

// Open opens a file, returning it or an error, if any happens.
func (fs *Fs) Open(name string) (afero.File, error) {
	return fs.tree.Open(fs, name)
}

// OpenFile opens a file using the given flags and the given mode.
func (fs *Fs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) {
	if 0x0 != flag&(^os.O_RDONLY) || 0x0 != perm&0xfffffbbb {
		return nil, syscall.EPERM
	}
	return fs.Open(name)
}

// Remove removes a file identified by name, returning an error, if any happens.
func (fs *Fs) Remove(name string) error { return syscall.EPERM }

// RemoveAll removes a directory path and any children it contains. It does not fail if the path does not exist (return nil).
func (fs *Fs) RemoveAll(path string) error { return syscall.EPERM }

// Rename renames a file.
func (fs *Fs) Rename(oldname, newname string) error { return syscall.EPERM }

// Stat returns a FileInfo describing the named file, or an error, if any happens.
func (fs *Fs) Stat(name string) (os.FileInfo, error) {
	file, err := fs.tree.Open(fs, name)
	if nil != err {
		return nil, err
	}
	return file.Stat()
}

// Name of this FileSystem
func (fs *Fs) Name() string { return "go-bindata" }

//Chmod changes the mode of the named file to mode.
func (fs *Fs) Chmod(name string, mode os.FileMode) error { return syscall.EPERM }

//Chtimes changes the access and modification times of the named file
func (fs *Fs) Chtimes(name string, atime time.Time, mtime time.Time) error { return syscall.EPERM }
